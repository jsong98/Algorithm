hashmap<동맹번호, 동맹> allies

// 군주.동맹번호로 접근
LinkedList<군주> 동맹
군주이름 --> 군주이름 --> 군주 이름

// 동맹번호를 key로 해당 동맹과 동맹관계인 동맹들의 HashSet을 value로
hashmap<동맹번호, HashSet<Integer>> 동맹관계

// 동맹번호를 key로 해당 동맹과 적대관계인 동맹들의 HashSet을 value로
hashmap<동맹번호, 동맹> 적대관계

// key(군주이름)과 동맹번호 value 매핑
hashmap<군주이름, 동맹번호> 동맹번호

Class 군주 {
  char[] 군주이름,
  int 동맹번호,
  int r좌표,
  int c좌표,
  int 병사의 수,
  군주 next
}

// 이미 동맹이면 -1, 적대관계면 -2, 성공하면 1
int ally(군주 A, 군주 B) {  // 8000번
  동맹관계인지 확인 ? -1 : cont.
  적대관계인지 확인 ? -2 : cont.

  군주A의 동맹.tail.next = 군주B의 동맹.head
  군주A의 동맹.tail = 군주B의 동맹.tail
  군주B의 동망에 속한 군주들의 allyNum을 군주A의 동맹번호로
  B군주와 동맹|적대관계인 군주들을 A군주 동맹|적대관계에 포함
  
}

// 공격이 승리하면 1, 방어에 성공하면 0, 이미 동맹이면 -1,
공격 영토 주변에 공격하는 동맹이 없는 경우 -2
int attack(군주 A, 군주 B, 장수) {  // 8000번
  동맹관계인지 확인 ? -1 : cont.
  군주A의 영토 또는 동맹 영토가 군주B의 영토와 인접한지 확인 ? -2 : cont.
  
  군주A와 B의 동맹 서로 적대관계 처리
  
  군주B의 영토에 인접한 군주A를 포함한 동맹의 보유한 병사 절반과
  군주B의 병사 + 군주B의 영토에 인접한 동맹의 병사 각 절반 비교(소수점은 버림)
  -->공격쪽 병사가 남으면 return 1, 모든 병사 사망 | 방어쪽 병사가 남으면 return 0
  
  공격 성공 {
    "동맹관계도, 적대관계도 없는 새로운 영토"--------
    새로운 영토의 군주는 장수, 군주A의 동맹에 편입, 적대관계는 군주A 관계와 동일
  }
  
}

// mOption 0 = 군주 하나의 영토에만 병사 모집, 해당 군주의 병사 return
mOption 1 = 해당 군주를 포함한 동맹 전체에 병사 모집, return 전체 병사의 수 합산
int recruit(군주, 병사수, 옵션) {  // 13,000번
  군주.동맹번호로 LinkedList에 접근 & 순회
  옵션이 0이면 해당 군주의 병사++ & return
  옵션이 1이면 해당 LinkedList에 존재하는 모든 군주의 병사++ & return
}

