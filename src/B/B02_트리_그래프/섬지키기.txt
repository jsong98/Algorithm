

void init(int N, int mMap[][]) {
    섬은 N x N 크기의 정사각형 모양이며, 1 x 1 크기의 정사각형 모양인 지역들로 이루어져 있음
    각 지역의 고도는 mMap[][]에 저장

    5 <= N <= 20
    1 <= mMap[][] <= 5

    호출되는 함수들 자체가 아무런 베이스가 없다면 완탐을 해야함
    => init()에서 무거운 연산을 최대한 처리, 가능한 모든 경우의 수를 미리 연산

    mStructure의 높이 == 1인 경우는 다 설치 가능하니까 continue;

    2 <= mStructure의 높이 <= 5에 대하여, 놓을 수 있는 지역들을 완전 탐색

    가능한 경우의 수를 hashing하여 counting 배열 or hashMap에 저장
        ex. 높이가 312인 구조물에 대해 놓을 수 있는 모든 경우의 수를 연산 및 저장
    이 때, 높이가 312인 구조물이나 높이가 423, 높이가 534인 구조물은 같은 패턴이고,
    놓을 수 있는 지역도 같기 때문에 같은 case로 취급
        적절한 hashing을 통해 표현, ex. 구조물의 첫번째 칸을 기준으로 hashing하거나, 바로 직전 칸을 기준으로 해도 됨
        이 때, reading 0에 유의, 제공코드에서는 바로 직전칸과 차이값 +5를 해줘서 1~9로 hashing
            ex. 15151 지형에 설치할 구조물의 예시는 5 1 5 1 5로 -4 +4 -4 +4로 1919로 hasing해서 저장
        +빠르게 푸는게 목적이라면, 그냥 1~55555 전부 저장해도 풀리긴 할 듯
    가로&세로뿐만 아니라 180도 뒤집는 경우(뒤집어도 똑같은 경우까지)도 고려해야 함
    counting 배열에 저장할 때, 첫번째 구조물이 시작하는 좌표값까지 저장해서 maxArea 최적화
        가로&세로 | 뒤집은 여부에 대한 정보까지 저장
        => class를 하나 만들어서 class의 List들에 대한 배열 생성해서 저장
}

int numberOfCandidate(int M, int mStructure[]) {    // 150,000 이하 호출
    구조물 mStructure를 1개 설치했을 때, 나타날 수 있는 경우의 수를 반환
    설치 지역이 모두 동일하면, 같은 경우로 취급
    설치 지역이 1개라도 다르다면 다른 경우로 취급

    구조물 mStructure의 크기는 1 x M이며, 1 x 1 크기의 정사각형 모양인 부분들로 이루어짐
    각 부분의 높이는 mStructure[]에 저장

    1 <= M <= 5
    1 <= mStructure[] <= 5
}

// 각 tc에서 maxArea() 함수의 구조물 mStructure를 설치할 수 있는 경우의 수는 5,000 이하
int maxArea(int M, int mStructure[], int mSeaLevel) {   // 50회 이하 호출
    해수면이 mSeaLevel만큼 상승하여도 바다에 잠기지 않고 남아있는 지역의 개수가 최대가 되도록
    구조물 mStructure를 1개 설치했을 때, 그 개수를 반환
    구조물 mStructure를 설치할 방법이 없는 경우에는 -1을 반환
    구조물 mStructure의 크기는 1 x M이며, 1 x 1 크기의 정사각형 모양인 부분들로 이루어짐
    각 부분의 높이는 mStructure[]에 저장
    실제로 설치하지는 않고, 각 tc에서 섬의 각 지역의 고도는 init() 상태로 시작

    1 <= M <= 5
    1 <= mStructure <= 5
    1 <= mSeaLevel <= 10
}

